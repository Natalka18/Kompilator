%{
	#include<iostream>
	#include<fstream>
	#include<string>
	#include<vector>
	#include<map>
	
	#include"Instruction.hpp"
	//#include"Value.hpp"
	#include"MemoryItem.hpp"
	
	using namespace std;
	
	int yylex();
	int yyerror(string);
	extern int yylineno;
	
	// odpowiada nieterminalom identifier i value
	struct value {
		bool isArray; // czy nieterminal odpowiada elementowi tablicy
		bool isVariable; // czy nieterminal odpowiada zwykłej zmiennej
		bool isNumber; // czy nieterminal odpowiada zwykłej liczbie
		string name; // nazwa zmiennej (lub tablicy)
		string index; // nazwa zmiennej, która jest indeksem elementu tablicy.
					  // Jeśli to nie jest tablica, to index=""
		long long index_long; // indeks elementu tablicy, któremu odpowiada ta struktura
							  // Jeśli to nie jest tablica, to index_long=-1
		long long num; //wartość liczby, jeśli isNumber=true
	};
	
	void yyset_out(FILE* out_str);
	FILE* yyget_out();
	
	long long memory_pointer = 1; //zmienić to
	vector<Instruction*> instructions; // wektor przechowujący kolejne instrukcje assemblerowe
	map<string,MemoryItem*> variables; // mapa przechwująca pary (nazwa zmiennej, komórka pamięci)
	
	void printInstructions();
	// funkcja dodaje do wektora variables nową zmienną. Zwraca true, jeśli operacja się powiedzie
	bool declareVariable(string name);
	// funkcja wczytuje wartość oraz zapisuje ją w zmiennej o nazwie name.
	// Zwraca true, jeśli operacja się powiedzie. Dodaje odpowiednie instrukcje assemblera
	bool loadValueToVariable(struct value* value);
	void printValue(struct value* value);
	// funkcja dodaje do wektora variables nową zmienną tablicową o początkowym
	// indeksie begin i końcowym indeksie end
	bool declareArray(string name, long long begin, long long end);
	// generuje instrukcje assemblerowe, które wygenerują liczbę number
	// i umieszczą ją w komórce pamięci o numerze cell
	void generateNumberAndStore(long long number, long long cell);
%}

%union {
	char* string;
	int integer;
	long long long_long;
	struct value* value_struct;
};

%type<value_struct> identifier
%type<value_struct> value;

%token DECLARE
%token BEGIN_TOKEN
%token END
%token ASSIGN
%token IF
%token THEN
%token ELSE
%token ENDIF
%token WHILE
%token DO
%token ENDWHILE
%token ENDDO
%token FOR
%token FROM
%token TO
%token ENDFOR
%token DOWNTO
%token READ
%token WRITE
%token PLUS
%token MINUS
%token TIMES
%token DIV
%token MOD
%token EQ
%token NEQ
%token LE
%token GE
%token LEQ
%token GEQ

%token<long_long> num
%token<string> pidentifier
%token comma
%token semicolon
%token colon
%token left_bracket
%token right_bracket

%token ERROR



%%

program       : DECLARE declarations BEGIN_TOKEN commands END {
	instructions.push_back(new Instruction("HALT"));
	printInstructions();
}
              | BEGIN_TOKEN commands END{
	instructions.push_back(new Instruction("HALT"));
	printInstructions();
}
;

declarations  : declarations comma pidentifier {
					declareVariable($3);
				}
              | declarations comma pidentifier left_bracket num colon num right_bracket {
              	declareArray($3, $5, $7);
              }
              | pidentifier {
              	declareVariable($1);
              }
              | pidentifier left_bracket num colon num right_bracket {
              	declareArray($1, $3, $5);
              }
              ;

commands      : commands command
              | command
              ;

command       : identifier ASSIGN expression semicolon
              | IF condition THEN commands ELSE commands ENDIF
              | IF condition THEN commands ENDIF
              | WHILE condition DO commands ENDWHILE
              | DO commands WHILE condition ENDDO
              | FOR pidentifier FROM value TO value DO commands ENDFOR
              | FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
              | READ identifier semicolon {
              	loadValueToVariable($2);
              }
              | WRITE value semicolon {
              	printValue($2);
              }
              ;

expression    : value
              | value PLUS value
              | value MINUS value
              | value TIMES value
              | value DIV value
              | value MOD value
              ;

condition     : value EQ value
              | value NEQ value
              | value LE value
              | value GE value
              | value LEQ value
              | value GEQ value
              ;

value         : num {
              	// robimy value z num (num jest long longiem)
              	value* newValue = new value;
				newValue->isArray = false;
				newValue->isVariable = false;
				newValue->isNumber = true;
				newValue->index = "";
				newValue->index_long = -1;
				newValue->name = "";
				newValue->num = $1;
				$$ = newValue;
              }
              | identifier {
              	$$ = $1;
              }
              ;

identifier    : pidentifier {
					// jeśli zmienna pidentifier nie jest zadeklarowana
					if(variables.find($1) == variables.end()) {
              			yyerror(string($1) + " was not declared");
              			return 1;
              		} else if(variables[$1]->isArray) { // jeśli zmienna pidentifier jest tablicą
              			yyerror(string($1) + " is an array");
              			return 1;
              		} else { // jeśli nie ma błędu w odwołaniu do pidentifier
					
						value* newValue = new value;
						newValue->isArray = false;
						newValue->isVariable = true;
						newValue->isNumber = false;
						newValue->index = "";
						newValue->index_long = -1;
						newValue->name = $1;
						$$ = newValue;
					}
}
              | pidentifier left_bracket pidentifier right_bracket {
              		// jeśli tablica nie została zadeklarowana 
              		if(variables.find($1) == variables.end()) {
              			yyerror(string($1) + " was not declared");
              			return 1;
              		} else if(!variables[$1]->isArray) { // jeśli to nie jest tablica
              			yyerror(string($1) + " is not an array");
              			return 1;
              		} else if(variables.find($3) == variables.end()) { // jeśli indeks nie jest zadeklarowyany
              			yyerror(string($3) + " was not declared");
              			return 1;
              		} else if(variables[$3]->isArray) { // jeśli indeks jest tablicą
              			yyerror(string($3) + " is an array");
              			return 1;
              		}
              		else { // jeśli poprawnie odwołano się do zmiennej
              	
              			value* newValue = new value;
						newValue->isArray = true;
						newValue->isVariable = false;
						newValue->isNumber = false;
						newValue->index = $3;
						newValue->index_long = -1;
						newValue->name = $1;
						$$ = newValue;
					}
				}
              
              
              | pidentifier left_bracket num right_bracket {
              
              	if(variables.find($1) == variables.end()) { // jeśli tablica nie jest zadeklarowana
              			yyerror(string($1) + " was not declared");
              			return 1;
              		} else if(!variables[$1]->isArray) { // jeśli to nie jest tablica
              			yyerror(string($1) + " is not an array");
              			return 1;
              		} else { // jeśli poprawnie odwołano się do tablicy
              			value* newValue = new value;
						newValue->isArray = true;
						newValue->isVariable = false;
						newValue->isNumber = false;
						newValue->index = "";
						newValue->index_long = $3;
						newValue->name = $1;
						$$ = newValue;
				}
              }
              ;

%%

int yyerror(string s) {
	cerr << "Line " << yylineno << ": " << s << endl;
	return 0;
}

void printInstructions() {
	for(int i=0; i<instructions.size(); i++) {
		fprintf(yyget_out(), "%s\n", instructions[i]->toString().c_str());
	}
}

bool declareVariable(string name) {
	// jeśli zmienna o nazwie name nie jest jeszcze zadeklarowana
	if(variables.find(name) == variables.end()) {
		MemoryItem* memory_item = new MemoryItem(memory_pointer, name);
		variables[name] = memory_item;
		
		memory_pointer++;
		
		//test
		cout<<name + ": "<<variables[name]->index<<endl;
	} else {
		yyerror("Duplicate variable \"" + name + "\"");
	}
}

bool loadValueToVariable(struct value* value) {
		if(value->isVariable) {
			// wczytanie wartość do akumulatora
			instructions.push_back(new Instruction("GET"));
			// zapisanie wartości z akumulatora do komórki o indeksie
			// odpowiadającym zmiennej o nazwie name
			instructions.push_back(new Instruction("STORE", variables[value->name]->index));
		} else {
			if(value->isArray) {
					// jeśli odwołanie do elementu tablicy następuje przez podanie liczby
					// jako numeru indeksu
					if(value->index_long != -1) {
						instructions.push_back(new Instruction("GET"));
						
						MemoryItem* memory_item = variables[value->name];
						
						// numer komórki pamięci, w której należy zapisać
						// wczytaną wartość (w ten sam sposób można ją później
						// znaleźć)
						long long index = memory_item->getMemoryIndexOf(value->index_long);
						
						instructions.push_back(new Instruction("STORE", index));
						
					} else { // jeśli odwołanie następuje przez podanie nazwy zmiennej
							// jako numeru indeksu 
						
						instructions.push_back(new Instruction("GET"));
						
						// miejsce w pamięci, gdzie znajduje się wartość zmiennej
						// określającej indeks tablicy
						long long memory_index_variable = variables[value->index]->index;
						
						
						
					}
			}
		}
		
		return true;
	
}


void printValue(struct value* value) {
		if(value->isVariable) {
			MemoryItem* item = variables[value->name];
			instructions.push_back(new Instruction("LOAD", item->index));
			instructions.push_back(new Instruction("PUT"));
		} else {
			
		}
}


bool declareArray(string name, long long begin, long long end) {
	// jeśli zmienna o nazwie name nie jest jeszcze zadeklarowana
	if(variables.find(name) == variables.end()) {
		if(begin >= end) {
			yyerror("Declaration of array " + name + " failed");
			return false;
		}
		long long size = end-begin+1;
		MemoryItem* memory_item = new MemoryItem(memory_pointer, true, size,
												name, begin, end);
		variables[name] = memory_item;
		
		//obliczenie wartości numer komórki pamięci, w której jest pierwszy
		// element talicy minus indeks begin tablicy.
		// Ta wartość jest potrzebna przy odwołaniu się do tablica(zmienna)
		long long number = memory_pointer - begin;
		
		// przesunięcie wskazania na wolną komórkę pamięci za tablicę
		memory_pointer = memory_pointer + size;
		
		
		// umieszczenie jej w komórce za tablicą
		generateNumberAndStore(number, memory_pointer);
		memory_item->additionalCell = memory_pointer;
		
		
		// przesunięcie memory_pointer za tę dodatkową komórkę
		memory_pointer++;
		
		// teraz aby obliczyć, w której komórce znajduje się element tablicy,
		// należy dodać do numeru indeksu wartość znajdującą się za tablicą
		
		//test
		cout<<name + ": "<<variables[name]->index<<endl;
		
	} else {
		yyerror("Duplicate variable \"" + name + "\"");
		return false;
	}
	
	return true;
}

// zamienia liczbę dziesiętną dodatnią na binarną i zapisuje ją w stringu
string decToBin(long long number) {
	string b = "";
	
	while(number > 0) {
		int r = number % 2;
		number = (number - r) / 2;
		
		if(r == 1) {
			b = "1" + b;
		} else {
			b = "0" + b;
		}
	}
	
	return b;
}

void generateNumberAndStore(long long number, long long cell) {

	cout<<number<<endl;

	// umieszczenie zera w akumulatorze
	instructions.push_back(new Instruction("SUB",0));

	if(number == 0) {
		instructions.push_back(new Instruction("STORE",cell));
		
	} else if(number > 0) {
		string b = decToBin(number);
		
		cout<<b<<endl;
		
		instructions.push_back(new Instruction("INC"));
		
		// wygenerowanie jedynki potrzebnej do shiftów (w komórce memory_pointer)
		// nie jest później potrzebna, więc nie zmieniamy
		// wartości memory_pointer
		instructions.push_back(new Instruction("STORE",memory_pointer));
		
		// w akumulatorze jest 1
		
		for(long long i=1; i<b.size(); i++) {
			instructions.push_back(new Instruction("SHIFT",memory_pointer));
			
			if(b[i] == '1') {
				instructions.push_back(new Instruction("INC"));
			}
		}
		
		instructions.push_back(new Instruction("STORE",cell));
		
	} else {
		number *= -1;
		string b = decToBin(number);
		
		// wygenerowanie jedynki potrzebnej do shiftów (w komórce memory_pointer)
		// nie jest później potrzebna, więc nie zmieniamy
		// wartości memory_pointer
		instructions.push_back(new Instruction("INC"));
		instructions.push_back(new Instruction("STORE",memory_pointer));
		
		instructions.push_back(new Instruction("DEC"));
		instructions.push_back(new Instruction("DEC"));
		
		// w akumulatorze jest -1
		
		for(long long i=1; i<b.size(); i++) {
			instructions.push_back(new Instruction("SHIFT",memory_pointer));
			
			if(b[i] == '1') {
				instructions.push_back(new Instruction("INC"));
			}
		}
		
		instructions.push_back(new Instruction("STORE",cell));
	}
}

