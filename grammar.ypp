%{
	#include<iostream>
	#include<fstream>
	#include<string>
	#include<vector>
	#include<map>
	
	#include"Instruction.hpp"
	//#include"Value.hpp"
	#include"MemoryItem.hpp"
	
	using namespace std;
	
	int yylex();
	int yyerror(string);
	extern int yylineno;
	
	// odpowiada nieterminalom identifier i value
	struct value {
		bool isArray; // czy nieterminal odpowiada elementowi tablicy
		bool isVariable; // czy nieterminal odpowiada zwykłej zmiennej
		bool isNumber; // czy nieterminal odpowiada zwykłej liczbie
		string name; // nazwa zmiennej (lub tablicy)
		string index; // nazwa zmiennej, która jest indeksem elementu tablicy
	};
	
	void yyset_out(FILE* out_str);
	FILE* yyget_out();
	
	long long memory_pointer = 1; //zmienić to
	vector<Instruction*> instructions; // wektor przechowujący kolejne instrukcje assemblerowe
	map<string,MemoryItem*> variables; // mapa przechwująca pary (nazwa zmiennej, komórka pamięci)
	
	void printInstructions();
	// funkcja dodaje do wektora variables nową zmienną. Zwraca true, jeśli operacja się powiedzie
	bool declareVariable(string name);
	// funkcja wczytuje wartość oraz zapisuje ją w zmiennej o nazwie name.
	// Zwraca true, jeśli operacja się powiedzie. Dodaje odpowiednie instrukcje assemblera
	bool loadValueToVariable(struct value* value);
	void printValue(struct value* value);
%}

%union {
	char* string;
	int integer;
	struct value* value_struct;
};

%type<value_struct> identifier
%type<value_struct> value;

%token DECLARE
%token BEGIN_TOKEN
%token END
%token ASSIGN
%token IF
%token THEN
%token ELSE
%token ENDIF
%token WHILE
%token DO
%token ENDWHILE
%token ENDDO
%token FOR
%token FROM
%token TO
%token ENDFOR
%token DOWNTO
%token READ
%token WRITE
%token PLUS
%token MINUS
%token TIMES
%token DIV
%token MOD
%token EQ
%token NEQ
%token LE
%token GE
%token LEQ
%token GEQ

%token<string> num
%token<string> pidentifier
%token comma
%token semicolon
%token colon
%token left_bracket
%token right_bracket

%token ERROR



%%

program       : DECLARE declarations BEGIN_TOKEN commands END {
	instructions.push_back(new Instruction("HALT"));
	printInstructions();
}
              | BEGIN_TOKEN commands END{
	instructions.push_back(new Instruction("HALT"));
	printInstructions();
}
;

declarations  : declarations comma pidentifier {
					declareVariable($3);
				}
              | declarations comma pidentifier left_bracket num colon num right_bracket
              | pidentifier {
              	declareVariable($1);
              }
              | pidentifier left_bracket num colon num right_bracket
              ;

commands      : commands command
              | command
              ;

command       : identifier ASSIGN expression semicolon
              | IF condition THEN commands ELSE commands ENDIF
              | IF condition THEN commands ENDIF
              | WHILE condition DO commands ENDWHILE
              | DO commands WHILE condition ENDDO
              | FOR pidentifier FROM value TO value DO commands ENDFOR
              | FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
              | READ identifier semicolon {
              	loadValueToVariable($2);
              }
              | WRITE value semicolon {
              	printValue($2);
              }
              ;

expression    : value
              | value PLUS value
              | value MINUS value
              | value TIMES value
              | value DIV value
              | value MOD value
              ;

condition     : value EQ value
              | value NEQ value
              | value LE value
              | value GE value
              | value LEQ value
              | value GEQ value
              ;

value         : num {
              	//$$ = $1;
              }
              | identifier {
              	$$ = $1;
              }
              ;

identifier    : pidentifier {
					//$$ = $1;
					value* newValue = new value;
					newValue->isArray = false;
					newValue->isVariable = true;
					newValue->isNumber = false;
					newValue->index = "";
					newValue->name = $1;
					$$ = newValue;
}
              | pidentifier left_bracket pidentifier right_bracket {
              	$$ = NULL; //chwilowo
              }
              | pidentifier left_bracket num right_bracket {
              	$$ = NULL; //chwilowo
              }
              ;

%%

int yyerror(string s) {
	cerr << "Line " << yylineno << ": " << s << endl;
	return 0;
}

void printInstructions() {
	for(int i=0; i<instructions.size(); i++) {
		fprintf(yyget_out(), "%s\n", instructions[i]->toString().c_str());
	}
}

bool declareVariable(string name) {
	// jeśli zmienna o nazwie name nie jest jeszcze zadeklarowana
	if(variables.find(name) == variables.end()) {
		MemoryItem* memory_item = new MemoryItem(memory_pointer, name);
		variables[name] = memory_item;
		
		memory_pointer++;
	} else {
		yyerror("Duplicate variable \"" + name + "\"");
	}
}

//bool loadValueToVariable(string name) {
	// jeśli zmienna o nazwie name nie jest zadeklarowana
	//if(variables.find(name) == variables.end()) {
		//yyerror(name + " was not declared");
		//return false;
	//} else {
		// inicjalizujemy zwykłą zmienną
		//if(!(variables[name]->isArray)) {
			// wczytanie wartość do akumulatora
			//instructions.push_back(new Instruction("GET"));
			// zapisanie wartości z akumulatora do komórki o indeksie
			// odpowiadającym zmiennej o nazwie name
			//instructions.push_back(new Instruction("STORE", variables[name]->index));
		//} else {
			
		//}
		
		//return true;
	//}
//}

bool loadValueToVariable(struct value* value) {
	// jeśli zmienna o nazwie name nie jest zadeklarowana
	if(variables.find(value->name) == variables.end()) {
		yyerror(value->name + " was not declared");
		return false;
	} else {
		if(value->isVariable) {
			// wczytanie wartość do akumulatora
			instructions.push_back(new Instruction("GET"));
			// zapisanie wartości z akumulatora do komórki o indeksie
			// odpowiadającym zmiennej o nazwie name
			instructions.push_back(new Instruction("STORE", variables[value->name]->index));
		} else {
			
		}
		
		return true;
	}
}


void printValue(struct value* value) {
	if(variables.find(value->name) == variables.end()) {
		yyerror(value->name + " was not declared");
	} else {
		if(value->isVariable) {
			MemoryItem* item = variables[value->name];
			instructions.push_back(new Instruction("LOAD", item->index));
			instructions.push_back(new Instruction("PUT"));
		} else {
			
		}
	}
}

