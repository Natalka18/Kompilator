%{
	#include<iostream>
	#include<string>
	#include<vector>
	#include<map>
	
	#include"Instruction.hpp"
	#include"Value.hpp"
	#include"MemoryItem.hpp"
	
	using namespace std;
	
	int yylex();
	int yyerror(string);
	extern int yylineno;
	
	long long memory_pointer = 1; //zmienić to
	vector<Instruction*> instructions; // wektor przechowujący kolejne instrukcje assemblerowe
	map<string,MemoryItem*> variables; // mapa przechwująca pary (nazwa zmiennej, komórka pamięci)
	
	void printInstructions();
	
	// funkcja dodaje do wektora variables nową zmienną. Zwraca true, jeśli operacja się powiedzie
	bool declareVariable(string name);
%}

%union {
	char* string;
	int integer;
};

%token DECLARE
%token BEGIN_TOKEN
%token END
%token ASSIGN
%token IF
%token THEN
%token ELSE
%token ENDIF
%token WHILE
%token DO
%token ENDWHILE
%token ENDDO
%token FOR
%token FROM
%token TO
%token ENDFOR
%token DOWNTO
%token READ
%token WRITE
%token PLUS
%token MINUS
%token TIMES
%token DIV
%token MOD
%token EQ
%token NEQ
%token LE
%token GE
%token LEQ
%token GEQ

%token num
%token<string> pidentifier
%token comma
%token semicolon
%token colon
%token left_bracket
%token right_bracket

%token ERROR



%%

program       : DECLARE declarations BEGIN_TOKEN commands END {
	instructions.push_back(new Instruction("HALT"));
	printInstructions();
}
              | BEGIN_TOKEN commands END{
	instructions.push_back(new Instruction("HALT"));
	printInstructions();
}
;

declarations  : declarations comma pidentifier {
					declareVariable($3);
				}
              | declarations comma pidentifier left_bracket num colon num right_bracket
              | pidentifier {
              	declareVariable($1);
              }
              | pidentifier left_bracket num colon num right_bracket
              ;

commands      : commands command
              | command
              ;

command       : identifier ASSIGN expression semicolon
              | IF condition THEN commands ELSE commands ENDIF
              | IF condition THEN commands ENDIF
              | WHILE condition DO commands ENDWHILE
              | DO commands WHILE condition ENDDO
              | FOR pidentifier FROM value TO value DO commands ENDFOR
              | FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
              | READ identifier semicolon
              | WRITE value semicolon
              ;

expression    : value
              | value PLUS value
              | value MINUS value
              | value TIMES value
              | value DIV value
              | value MOD value
              ;

condition     : value EQ value
              | value NEQ value
              | value LE value
              | value GE value
              | value LEQ value
              | value GEQ value
              ;

value         : num
              | identifier
              ;

identifier    : pidentifier
              | pidentifier left_bracket pidentifier right_bracket
              | pidentifier left_bracket num right_bracket
              ;

%%

int yyerror(string s) {
	cerr << "Line " << yylineno << ": " << s << endl;
	return 0;
}

void printInstructions() {
	for(int i=0; i<instructions.size(); i++) {
		cout << instructions[i]->toString() << endl;
	}
}

bool declareVariable(string name) {
	// jeśli zmienna o nazwie name nie jest jeszcze zadeklarowana
	
	if(variables.find(name) == variables.end()) {
		MemoryItem* memory_item = new MemoryItem(memory_pointer, name);
		variables[name] = memory_item;
		
		memory_pointer++;
	} else {
		yyerror("Duplicate variable \"" + name + "\"");
	}
}


