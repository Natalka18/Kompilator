%{
	#include<iostream>
	#include<fstream>
	#include<string>
	#include<vector>
	#include<map>
	
	#include"Instruction.hpp"
	//#include"Value.hpp"
	#include"MemoryItem.hpp"
	
	using namespace std;
	
	int yylex();
	int yyerror(string);
	extern int yylineno;
	
	// odpowiada nieterminalom identifier i value
	struct value {
		bool isArray; // czy nieterminal odpowiada elementowi tablicy
		bool isVariable; // czy nieterminal odpowiada zwykłej zmiennej
		bool isNumber; // czy nieterminal odpowiada zwykłej liczbie
		string name; // nazwa zmiennej (lub tablicy)
		string index; // nazwa zmiennej, która jest indeksem elementu tablicy.
					  // Jeśli to nie jest tablica, to index=""
		long long index_long; // indeks elementu tablicy, któremu odpowiada ta struktura
							  // Jeśli to nie jest tablica, to index_long=-1
		long long num; //wartość liczby, jeśli isNumber=true
	};
	
	void yyset_out(FILE* out_str);
	FILE* yyget_out();
	
	long long memory_pointer = 1; //zmienić to
	vector<Instruction*> instructions; // wektor przechowujący kolejne instrukcje assemblerowe
	map<string,MemoryItem*> variables; // mapa przechwująca pary (nazwa zmiennej, komórka pamięci)
	
	void printInstructions();
	// funkcja dodaje do wektora variables nową zmienną. Zwraca true, jeśli operacja się powiedzie
	bool declareVariable(string name);
	// funkcja wczytuje wartość oraz zapisuje ją w zmiennej o nazwie name.
	// Zwraca true, jeśli operacja się powiedzie. Dodaje odpowiednie instrukcje assemblera
	bool loadValueToVariable(struct value* value);
	void printValue(struct value* value);
	// funkcja dodaje do wektora variables nową zmienną tablicową o początkowym
	// indeksie begin i końcowym indeksie end
	bool declareArray(string name, long long begin, long long end);
%}

%union {
	char* string;
	int integer;
	long long long_long;
	struct value* value_struct;
};

%type<value_struct> identifier
%type<value_struct> value;

%token DECLARE
%token BEGIN_TOKEN
%token END
%token ASSIGN
%token IF
%token THEN
%token ELSE
%token ENDIF
%token WHILE
%token DO
%token ENDWHILE
%token ENDDO
%token FOR
%token FROM
%token TO
%token ENDFOR
%token DOWNTO
%token READ
%token WRITE
%token PLUS
%token MINUS
%token TIMES
%token DIV
%token MOD
%token EQ
%token NEQ
%token LE
%token GE
%token LEQ
%token GEQ

%token<long_long> num
%token<string> pidentifier
%token comma
%token semicolon
%token colon
%token left_bracket
%token right_bracket

%token ERROR



%%

program       : DECLARE declarations BEGIN_TOKEN commands END {
	instructions.push_back(new Instruction("HALT"));
	printInstructions();
}
              | BEGIN_TOKEN commands END{
	instructions.push_back(new Instruction("HALT"));
	printInstructions();
}
;

declarations  : declarations comma pidentifier {
					declareVariable($3);
				}
              | declarations comma pidentifier left_bracket num colon num right_bracket {
              	declareArray($3, $5, $7);
              }
              | pidentifier {
              	declareVariable($1);
              }
              | pidentifier left_bracket num colon num right_bracket {
              	declareArray($1, $3, $5);
              }
              ;

commands      : commands command
              | command
              ;

command       : identifier ASSIGN expression semicolon
              | IF condition THEN commands ELSE commands ENDIF
              | IF condition THEN commands ENDIF
              | WHILE condition DO commands ENDWHILE
              | DO commands WHILE condition ENDDO
              | FOR pidentifier FROM value TO value DO commands ENDFOR
              | FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
              | READ identifier semicolon {
              	loadValueToVariable($2);
              }
              | WRITE value semicolon {
              	printValue($2);
              }
              ;

expression    : value
              | value PLUS value
              | value MINUS value
              | value TIMES value
              | value DIV value
              | value MOD value
              ;

condition     : value EQ value
              | value NEQ value
              | value LE value
              | value GE value
              | value LEQ value
              | value GEQ value
              ;

value         : num {
              	// robimy value z num (num jest long longiem)
              	value* newValue = new value;
				newValue->isArray = false;
				newValue->isVariable = false;
				newValue->isNumber = true;
				newValue->index = "";
				newValue->index_long = -1;
				newValue->name = "";
				newValue->num = $1;
				$$ = newValue;
              }
              | identifier {
              	$$ = $1;
              }
              ;

identifier    : pidentifier {
					value* newValue = new value;
					newValue->isArray = false;
					newValue->isVariable = true;
					newValue->isNumber = false;
					newValue->index = "";
					newValue->index_long = -1;
					newValue->name = $1;
					$$ = newValue;
}
              | pidentifier left_bracket pidentifier right_bracket {
              	value* newValue = new value;
				newValue->isArray = true;
				newValue->isVariable = false;
				newValue->isNumber = false;
				newValue->index = $3;
				newValue->index_long = -1;
				newValue->name = $1;
				$$ = newValue;
              }
              | pidentifier left_bracket num right_bracket {
              	value* newValue = new value;
				newValue->isArray = true;
				newValue->isVariable = false;
				newValue->isNumber = false;
				newValue->index = "";
				newValue->index_long = $3;
				newValue->name = $1;
				$$ = newValue;
              }
              ;

%%

int yyerror(string s) {
	cerr << "Line " << yylineno << ": " << s << endl;
	return 0;
}

void printInstructions() {
	for(int i=0; i<instructions.size(); i++) {
		fprintf(yyget_out(), "%s\n", instructions[i]->toString().c_str());
	}
}

bool declareVariable(string name) {
	// jeśli zmienna o nazwie name nie jest jeszcze zadeklarowana
	if(variables.find(name) == variables.end()) {
		MemoryItem* memory_item = new MemoryItem(memory_pointer, name);
		variables[name] = memory_item;
		
		cout<<name<<": "<<memory_pointer<<endl;
		
		memory_pointer++;
	} else {
		yyerror("Duplicate variable \"" + name + "\"");
	}
}

bool loadValueToVariable(struct value* value) {
	// jeśli zmienna o nazwie name nie jest zadeklarowana
	if(variables.find(value->name) == variables.end()) {
		yyerror(value->name + " was not declared");
		return false;
	} else {
		if(value->isVariable) {
			if(value->index != "" || value->index_long != -1) {
					yyerror(value->name + " is not an array. Syntax: READ ");
					return false;
			}
			// wczytanie wartość do akumulatora
			instructions.push_back(new Instruction("GET"));
			// zapisanie wartości z akumulatora do komórki o indeksie
			// odpowiadającym zmiennej o nazwie name
			instructions.push_back(new Instruction("STORE", variables[value->name]->index));
		} else {
			if(value->isArray) {
				// jeśli nie podano indeksu przy odwołaniu do tablicy
				if(value->index == "" && value->index_long == -1) {
					yyerror(value->name + " is an array. Syntax: READ " + value->name + \
							"(index)");
					return false;
				} else {
					// jeśli odwołanie do elementu tablicy następuje przez podanie liczby
					// jako numeru indeksu
					if(value->index_long != -1) {
						instructions.push_back(new Instruction("GET"));
						
						MemoryItem* memory_item = variables[value->name];
						
						// numer komórki pamięci, w której należy zapisać
						// wczytaną wartość (w ten sam sposób można ją później
						// znaleźć)
						long long index = memory_item->getMemoryIndexOf(value->index_long);
						
						instructions.push_back(new Instruction("STORE", index));
						
					} else { // jeśli odwołanie następuje przez podanie nazwy zmiennej
							// jako numeru indeksu
						// jeśli ta zmienna nie istnieje
						if(variables.find(value->index) == variables.end()) {
							yyerror(value->name + " was not declared");
							return false;
						} 
						
						instructions.push_back(new Instruction("GET"));
						
						// miejsce w pamięci, gdzie znajduje się wartość zmiennej
						// określającej indeks tablicy
						long long memory_index_variable = variables[value->index]->index;
						
						
						
					}
				}
			}
		}
		
		return true;
	}
}


void printValue(struct value* value) {
	if(variables.find(value->name) == variables.end()) {
		yyerror(value->name + " was not declared");
	} else {
		if(value->isVariable) {
			MemoryItem* item = variables[value->name];
			instructions.push_back(new Instruction("LOAD", item->index));
			instructions.push_back(new Instruction("PUT"));
		} else {
			
		}
	}
}


bool declareArray(string name, long long begin, long long end) {
	// jeśli zmienna o nazwie name nie jest jeszcze zadeklarowana
	if(variables.find(name) == variables.end()) {
		if(begin >= end) {
			yyerror("Declaration of array " + name + " failed");
			return false;
		}
		long long size = end-begin+1;
		MemoryItem* memory_item = new MemoryItem(memory_pointer, true, size,
												name, begin, end);
		variables[name] = memory_item;
		
		cout<<name<<": "<<memory_pointer<<endl;
		
		memory_pointer = memory_pointer + size;
	} else {
		yyerror("Duplicate variable \"" + name + "\"");
		return false;
	}
	
	return true;
}

