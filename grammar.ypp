%{
	#include<iostream>
	#include<fstream>
	#include<string>
	#include<vector>
	#include<map>
	#include<stack>
	
	#include"Instruction.hpp"
	//#include"Value.hpp"
	#include"MemoryItem.hpp"
	
	using namespace std;
	
	int yylex();
	int yyerror(string);
	extern int yylineno;
	
	// odpowiada nieterminalom identifier i value
	struct value {
		bool isArray; // czy nieterminal odpowiada elementowi tablicy
		bool isVariable; // czy nieterminal odpowiada zwykłej zmiennej
		bool isNumber; // czy nieterminal odpowiada zwykłej liczbie
		string name; // nazwa zmiennej (lub tablicy)
		string index; // nazwa zmiennej, która jest indeksem elementu tablicy.
					  // Jeśli to nie jest tablica, to index=""
		long long index_long; // indeks elementu tablicy, któremu odpowiada ta struktura
							  // Jeśli to nie jest tablica, to index_long=-1
		long long num; //wartość liczby, jeśli isNumber=true
	};
	
	// oznacza numer komórki pamięci
	struct cell {
		long long cell; // oznacza numer komórki
		bool containsValue; // true, jeśli cell oznacza numer komórki, w której przechowywana
							// jest dana wartość
		bool containsIndex; // true, jeśli cell oznacza numer komórki, której znajduje się
							// numer komórki, w której znajduje się dana wartość
		bool valueIsNumber; // true, jeśli value było num
	};
	
	// odpowiada warunkowi condition
	struct cond {
		struct value* value1;
		struct value* value2;
		string op; // rodzaj porównania (EQ, NEQ, LE itd.)
	};
	
	// stos służący do przechowywania numerów instrukcji w celu ominięcia poleceń
	// znajdujących się wewnątrz ifa (lub else'a).
	// Przechowywane są numery jumpów, żeby móc później zmienić ich argument
	stack<long long> ifLinePointerStack;
	
	// stos przechowujący numery instrukcji, do których trzeba skoczyć w celu powrotu
	// do sprawdzenia warunku pętli
	stack<long long> whileConditionPointerStack;
	
	// stos przechowujący numery instrukcji, w których są jumpy (które przenoszą za pętlę).
	// Potrzebne do późniejszej zmiany argumentu jumpów
	stack<long long> whileLinePointerStack;
	
	// przechowuje miejsca, do których trzeba skoczyć, żeby wrócić do początku DO
	// w pętli DO WHILE
	stack<long long> doWhileLinePointerStack;
	
	void yyset_out(FILE* out_str);
	FILE* yyget_out();
	
	long long memory_pointer = 1; //zmienić to
	vector<Instruction*> instructions; // wektor przechowujący kolejne instrukcje assemblerowe
	map<string,MemoryItem*> variables; // mapa przechwująca pary (nazwa zmiennej, komórka pamięci)
	
	void printInstructions();
	// funkcja dodaje do wektora variables nową zmienną. Zwraca true, jeśli operacja się powiedzie
	bool declareVariable(string name);
	// funkcja wczytuje wartość oraz zapisuje ją w zmiennej o nazwie name.
	// Zwraca true, jeśli operacja się powiedzie. Dodaje odpowiednie instrukcje assemblera
	bool loadValueToVariable(struct value* value);
	void printValue(struct value* value);
	// funkcja dodaje do wektora variables nową zmienną tablicową o początkowym
	// indeksie begin i końcowym indeksie end
	bool declareArray(string name, long long begin, long long end);
	// generuje instrukcje assemblerowe, które wygenerują liczbę number
	// i umieszczą ją w komórce pamięci o numerze cell
	void generateNumberAndStore(long long number, long long cell);
	// generuje instrukcje, które umieszczą w akumulatorze numer komórki,
	// w której przechowywana jest wartość elementu o indeksie variable 
	// tablicy array
	void calculateIndexOfArrayElement(string array, string variable);
	// generuje instrukcje, które umieszczą w akumulatorze wartość odpowiadającą
	// strukturze value
	void loadValueToAccumulator(struct value* value);
	// generuje instrukcje, które umieszczą w value wartość z komórki
	// o numerze cell.
	// Odpowiednik funkcji loadValueToVariable, ale tam zapisywana jest w zmiennej
	// wartość z akumulatora, a tu z dowolnej komórki.
	// Służy do zapisywania wartości z komórki cell w zmiennej, której odpowiada
	// struktura value.
	void storeValueFromCell(struct value* value, long long cell);
	// zwraca cell, która odpowiada danej wartości value
	struct cell* findValueInMemory(struct value* value);
	// dodaje liczby z value1 i value2 i umieszcza wynik w komórce o numerze result_cell
	void add(struct value* value1, struct value* value2, long long result_cell);
	// odejmuje liczby z value1 i value2 i umieszcza wynik w komórce o numerze result_cell
	void subtract(struct value* value1, struct value* value2, long long result_cell);
	// mnoży liczby z value1 i value2 i umieszcza wynik w komórce o numerze result_cell
	void multiply(struct value* value1, struct value* value2, long long result_cell);
	// dzieli liczby z value1 i value2 i umieszcza wynik w komórce o numerze result_cell.
	// Jeśli mod jest true, to zamiast wyniku dzielenia umieszcza resztę w result_cell
	void divide(struct value* value1, struct value* value2, long long result_cell, bool mod);
	// umieszcza w akumulatorze wartość do sprawdzenia (value1-value2), następnie wykonuje 
	// skok do instrukcji o numerze k
	void checkConditionNegation(struct cond* c, long long k); // if, while
	void checkCondition(struct cond* c, long long k); // do while
%}

%define parse.error verbose
%define parse.lac full

%union {
	char* string;
	int integer;
	long long long_long;
	struct value* value_struct;
	struct result* result_struct;
	struct cond* cond_struct;
};

%type<value_struct> identifier
%type<value_struct> value;
%type<long_long> expression; // expression ma wartość numeru komórki, w której znajduje się wynik
%type<cond_struct> condition;

%token DECLARE
%token BEGIN_TOKEN
%token END
%token ASSIGN
%token IF
%token THEN
%token ELSE
%token ENDIF
%token WHILE
%token DO
%token ENDWHILE
%token ENDDO
%token FOR
%token FROM
%token TO
%token ENDFOR
%token DOWNTO
%token READ
%token WRITE
%token PLUS
%token MINUS
%token TIMES
%token DIV
%token MOD
%token EQ
%token NEQ
%token LE
%token GE
%token LEQ
%token GEQ

%token<long_long> num
%token<string> pidentifier
%token comma
%token semicolon
%token colon
%token left_bracket
%token right_bracket

%token ERROR



%%

program       : DECLARE declarations BEGIN_TOKEN commands END {
	instructions.push_back(new Instruction("HALT"));
	printInstructions();
}
              | BEGIN_TOKEN commands END{
	instructions.push_back(new Instruction("HALT"));
	printInstructions();
}
;

declarations  : declarations comma pidentifier {
					declareVariable($3);
				}
              | declarations comma pidentifier left_bracket num colon num right_bracket {
              	declareArray($3, $5, $7);
              }
              | pidentifier {
              	declareVariable($1);
              }
              | pidentifier left_bracket num colon num right_bracket {
              	declareArray($1, $3, $5);
              }
              ;

commands      : commands command {
					//cout<<"commands"<<endl;
					//cout<<instructions.size()<<endl;
				}
              | command
              ;

command       : identifier ASSIGN expression semicolon {
					storeValueFromCell($1, $3);
					memory_pointer--; // patrz expression: value
				}
              | IF condition {
              		checkConditionNegation($2,0); // narazie nie da się ustalić, dokąd ma być skok
              		ifLinePointerStack.push(instructions.size()-1);
              } THEN commands {
              		long long jumpIndex = ifLinePointerStack.top();
              		ifLinePointerStack.pop();
              		Instruction* instruction = instructions[jumpIndex];
              		
              		// skok, który skacze instrukcję dalej (k:=k+1)
              		// jeśli później wystąpi else, to zmienimy argument tak,
              		// żeby skakać za else'a
              		instructions.push_back(new Instruction("JUMP",instructions.size() + 1));
              		
              		// dajemy na stos indeks powyższego jumpa
              		ifLinePointerStack.push(instructions.size()-1);
              		
              		instruction->arg = instructions.size();
              		
              } end_if
              | WHILE condition {
              		// póżniej będziemy skakać do początku sprawdzania warunku
              		whileConditionPointerStack.push(instructions.size());
              		
              		checkConditionNegation($2,0); // narazie nie da się ustalić, dokąd ma być skok
              		
              		// na drugim stosie umieszczamy, w której linii znajduje się skok
              		// (JNEG, JZERO, JPOS), w którym trzeba ustalić miejsce skoku
              		whileLinePointerStack.push(instructions.size() - 1);
              		
              } DO commands ENDWHILE {
              		long long conditionPointer = whileConditionPointerStack.top();
              		whileConditionPointerStack.pop();
              		
              		long long linePointer = whileLinePointerStack.top();
              		whileLinePointerStack.pop();
              		
              		// dodajemy jumpa, który wróci do sprawdzenia warunku
              		instructions.push_back(new Instruction("JUMP",conditionPointer));
              		
              		// jeśli warunek while'a nie jest spełniony, to trzeba skakać
              		// za powyższego jumpa
              		instructions[linePointer]->arg = instructions.size();
              }
              | DO {
              		doWhileLinePointerStack.push(instructions.size());
              		
              } commands WHILE condition ENDDO {
              		checkCondition($5,0);
              		long long jumpIndex = instructions.size()-1;
              		long long loopBegin = doWhileLinePointerStack.top();
              		doWhileLinePointerStack.pop();
              		
              		instructions[jumpIndex]->arg = loopBegin;
              }
              | FOR pidentifier FROM value TO value DO commands ENDFOR
              | FOR pidentifier FROM value DOWNTO value DO commands ENDFOR
              | READ identifier semicolon {
              	loadValueToVariable($2);
              }
              | WRITE value semicolon {
              	printValue($2);
              }
              ;
              
end_if        : ELSE {
              		
				} commands ENDIF {
					// ściągamy ze stosu indeks jumpa, którego argument chcemy zmienić
					// (ma skakać za else'a)
					long long jumpIndex = ifLinePointerStack.top();
              		ifLinePointerStack.pop();
              		Instruction* instruction = instructions[jumpIndex];
              		instruction->arg = instructions.size();
				}
			  | ENDIF {
			  		// nie było else'a po ifie. Ściągamy niepotrzebną daną ze stosu
			  		ifLinePointerStack.pop();
			  }
			  ;

expression    : value {
					loadValueToAccumulator($1);
					
					// umieścimy w wolnej komórce i zwiększymy wskaźnik wolnej komórki
					instructions.push_back(new Instruction("STORE",memory_pointer));
					
					// wartość wyrażenia umieściliśmy w komórce memory_pointer
					$$=memory_pointer;
					
					memory_pointer++; // póżniej komórka z wartością wyrażenia nie jest potrzebna
									  // trzeba to zmienić
									  // może można w assign zrobić memory_pointer-- ?
				}
              | value PLUS value {
              	add($1,$3,memory_pointer);
              	$$=memory_pointer;
              	memory_pointer++;
              }
              | value MINUS value {
              	subtract($1,$3,memory_pointer);
              	$$=memory_pointer;
              	memory_pointer++;
              }
              | value TIMES value {
              	multiply($1,$3,memory_pointer);
              	$$=memory_pointer;
              	memory_pointer++;
              }
              | value DIV value {
              	divide($1,$3,memory_pointer,false);
              	$$=memory_pointer;
              	memory_pointer++;
              }
              | value MOD value {
              	divide($1,$3,memory_pointer,true);
              	$$=memory_pointer;
              	memory_pointer++;
              }
              ;

condition     : value EQ value {
					cond* c = new cond;
					c->op = "EQ";
					c->value1 = $1;
					c->value2 = $3;
					
					$$ = c;
				}
              | value NEQ value {
              		cond* c = new cond;
					c->op = "NEQ";
					c->value1 = $1;
					c->value2 = $3;
					
					$$ = c;
              }
              | value LE value {
              		cond* c = new cond;
					c->op = "LE";
					c->value1 = $1;
					c->value2 = $3;
					
					$$ = c;
              }
              | value GE value {
              		cond* c = new cond;
					c->op = "GE";
					c->value1 = $1;
					c->value2 = $3;
					
					$$ = c;
              }
              | value LEQ value {
              		cond* c = new cond;
					c->op = "LEQ";
					c->value1 = $1;
					c->value2 = $3;
					
					$$ = c;
              }
              | value GEQ value {
              		cond* c = new cond;
					c->op = "GEQ";
					c->value1 = $1;
					c->value2 = $3;
					
					$$ = c;
              }
              ;

value         : num {
              	// robimy value z num (num jest long longiem)
              	value* newValue = new value;
				newValue->isArray = false;
				newValue->isVariable = false;
				newValue->isNumber = true;
				newValue->index = "";
				newValue->index_long = -1;
				newValue->name = "";
				newValue->num = $1;
				$$ = newValue;
              }
              | identifier {
              	$$ = $1;
              }
              ;

identifier    : pidentifier {
					// jeśli zmienna pidentifier nie jest zadeklarowana
					if(variables.find($1) == variables.end()) {
              			yyerror(string($1) + " was not declared");
              			return 1;
              		} else if(variables[$1]->isArray) { // jeśli zmienna pidentifier jest tablicą
              			yyerror(string($1) + " is an array");
              			return 1;
              		} else { // jeśli nie ma błędu w odwołaniu do pidentifier
					
						value* newValue = new value;
						newValue->isArray = false;
						newValue->isVariable = true;
						newValue->isNumber = false;
						newValue->index = "";
						newValue->index_long = -1;
						newValue->name = $1;
						$$ = newValue;
					}
}
              | pidentifier left_bracket pidentifier right_bracket {
              		// jeśli tablica nie została zadeklarowana 
              		if(variables.find($1) == variables.end()) {
              			yyerror(string($1) + " was not declared");
              			return 1;
              		} else if(!variables[$1]->isArray) { // jeśli to nie jest tablica
              			yyerror(string($1) + " is not an array");
              			return 1;
              		} else if(variables.find($3) == variables.end()) { // jeśli indeks nie jest zadeklarowany
              			yyerror(string($3) + " was not declared");
              			return 1;
              		} else if(variables[$3]->isArray) { // jeśli indeks jest tablicą
              			yyerror(string($3) + " is an array");
              			return 1;
              		}
              		else { // jeśli poprawnie odwołano się do zmiennej
              	
              			value* newValue = new value;
						newValue->isArray = true;
						newValue->isVariable = false;
						newValue->isNumber = false;
						newValue->index = $3;
						newValue->index_long = -1;
						newValue->name = $1;
						$$ = newValue;
					}
				}
              
              
              | pidentifier left_bracket num right_bracket {
              
              	if(variables.find($1) == variables.end()) { // jeśli tablica nie jest zadeklarowana
              			yyerror(string($1) + " was not declared");
              			return 1;
              		} else if(!variables[$1]->isArray) { // jeśli to nie jest tablica
              			yyerror(string($1) + " is not an array");
              			return 1;
              		} else { // jeśli poprawnie odwołano się do tablicy
              			value* newValue = new value;
						newValue->isArray = true;
						newValue->isVariable = false;
						newValue->isNumber = false;
						newValue->index = "";
						newValue->index_long = $3;
						newValue->name = $1;
						$$ = newValue;
				}
              }
              ;

%%

int yyerror(string s) {
	cerr << "Line " << yylineno << ": " << s << endl;
	return 0;
}

void printInstructions() {
	for(int i=0; i<instructions.size(); i++) {
		fprintf(yyget_out(), "%s\n", instructions[i]->toString().c_str());
	}
}

bool declareVariable(string name) {
	// jeśli zmienna o nazwie name nie jest jeszcze zadeklarowana
	if(variables.find(name) == variables.end()) {
		MemoryItem* memory_item = new MemoryItem(memory_pointer, name);
		variables[name] = memory_item;
		
		memory_pointer++;
		
		//test
		//cout<<name + ": "<<variables[name]->index<<endl;
	} else {
		yyerror("Duplicate variable \"" + name + "\"");
	}
}

bool loadValueToVariable(struct value* value) {
		if(value->isVariable) {
			// wczytanie wartość do akumulatora
			instructions.push_back(new Instruction("GET"));
			// zapisanie wartości z akumulatora do komórki o indeksie
			// odpowiadającym zmiennej o nazwie name
			instructions.push_back(new Instruction("STORE", variables[value->name]->index));
		} else {
			if(value->isArray) {
					// jeśli odwołanie do elementu tablicy następuje przez podanie liczby
					// jako numeru indeksu
					if(value->index_long != -1) {
						instructions.push_back(new Instruction("GET"));
						
						MemoryItem* memory_item = variables[value->name];
						
						// numer komórki pamięci, w której należy zapisać
						// wczytaną wartość (w ten sam sposób można ją później
						// znaleźć)
						long long index = memory_item->getMemoryIndexOf(value->index_long);
						
						instructions.push_back(new Instruction("STORE", index));
						
					} else { // jeśli odwołanie następuje przez podanie nazwy zmiennej
							// jako numeru indeksu 
						
						calculateIndexOfArrayElement(value->name, value->index);
						
						// zapisanie tej wartości w wolnej komórce
						instructions.push_back(new Instruction("STORE", memory_pointer));
						// teraz indeks interesującego nas elementu tablicy jest w komórce
						// o numerze memory_pointer
						
						// wczytanie wartości do akumulatora
						instructions.push_back(new Instruction("GET"));
						
						// umieszczenie wczytanej wartości w komórce, która odpowiada
						// interesującemu nas elementowi tablicy
						instructions.push_back(new Instruction("STOREI",memory_pointer));
						
					}
			}
		}
		
		return true;
	
}

void storeValueFromCell(struct value* value, long long cell) {
	if(value->isVariable) {
			// wczytanie wartość do akumulatora
			instructions.push_back(new Instruction("LOAD",cell));
			// zapisanie wartości z akumulatora do komórki o indeksie
			// odpowiadającym zmiennej o nazwie name
			instructions.push_back(new Instruction("STORE", variables[value->name]->index));
		} else {
			if(value->isArray) {
					// jeśli odwołanie do elementu tablicy następuje przez podanie liczby
					// jako numeru indeksu
					if(value->index_long != -1) {
						instructions.push_back(new Instruction("LOAD", cell));
						
						MemoryItem* memory_item = variables[value->name];
						
						// numer komórki pamięci, w której należy zapisać
						// wczytaną wartość (w ten sam sposób można ją później
						// znaleźć)
						long long index = memory_item->getMemoryIndexOf(value->index_long);
						
						instructions.push_back(new Instruction("STORE", index));
						
					} else { // jeśli odwołanie następuje przez podanie nazwy zmiennej
							// jako numeru indeksu 
						
						calculateIndexOfArrayElement(value->name, value->index);
						
						// zapisanie tej wartości w wolnej komórce
						instructions.push_back(new Instruction("STORE", memory_pointer));
						// teraz indeks interesującego nas elementu tablicy jest w komórce
						// o numerze memory_pointer
						
						// wczytanie wartości do akumulatora
						instructions.push_back(new Instruction("LOAD",cell));
						
						// umieszczenie wczytanej wartości w komórce, która odpowiada
						// iteresującemu nas elementowi tablicy
						instructions.push_back(new Instruction("STOREI",memory_pointer));
						
					}
			} 
		}
}


void printValue(struct value* value) {
		
		loadValueToAccumulator(value);
		instructions.push_back(new Instruction("PUT"));
}


bool declareArray(string name, long long begin, long long end) {
	// jeśli zmienna o nazwie name nie jest jeszcze zadeklarowana
	if(variables.find(name) == variables.end()) {
		if(begin >= end) {
			yyerror("Declaration of array " + name + " failed");
			return false;
		}
		long long size = end-begin+1;
		MemoryItem* memory_item = new MemoryItem(memory_pointer, true, size,
												name, begin, end);
		variables[name] = memory_item;
		
		//obliczenie wartości numer komórki pamięci, w której jest pierwszy
		// element talicy minus indeks begin tablicy.
		// Ta wartość jest potrzebna przy odwołaniu się do tablica(zmienna)
		long long number = memory_pointer - begin;
		
		// przesunięcie wskazania na wolną komórkę pamięci za tablicę
		memory_pointer = memory_pointer + size;
		
		
		// umieszczenie jej w komórce za tablicą
		generateNumberAndStore(number, memory_pointer);
		memory_item->additionalCell = memory_pointer;
		
		
		// przesunięcie memory_pointer za tę dodatkową komórkę
		memory_pointer++;
		
		// teraz aby obliczyć, w której komórce znajduje się element tablicy,
		// należy dodać do numeru indeksu wartość znajdującą się za tablicą
		
		//test
		//cout<<name + ": "<<variables[name]->index<<endl;
		
	} else {
		yyerror("Duplicate variable \"" + name + "\"");
		return false;
	}
	
	return true;
}


void calculateIndexOfArrayElement(string array, string variable) {
	// miejsce w pamięci, gdzie znajduje się wartość zmiennej
	// określającej indeks tablicy
	long long variableCell = variables[variable]->index;
	
	// ładujemy wartość zmiennej określającej indeks do akumulatora
	instructions.push_back(new Instruction("LOAD",variableCell));
	
	// dodajemy do niej wartość umieszczoną za tablicą (index-begin, 
	// patrz MemoryItem, getMemoryIndexOf)
	instructions.push_back(new Instruction("ADD",variables[array]->additionalCell));
}



// zamienia liczbę dziesiętną dodatnią na binarną i zapisuje ją w stringu
string decToBin(long long number) {
	string b = "";
	
	while(number > 0) {
		int r = number % 2;
		number = (number - r) / 2;
		
		if(r == 1) {
			b = "1" + b;
		} else {
			b = "0" + b;
		}
	}
	
	return b;
}

void generateNumberAndStore(long long number, long long cell) {

	//cout<<number<<endl;

	// umieszczenie zera w akumulatorze
	instructions.push_back(new Instruction("SUB",0));

	if(number == 0) {
		instructions.push_back(new Instruction("STORE",cell));
		
	} else if(number > 0) {
		string b = decToBin(number);
		
		//cout<<b<<endl;
		
		instructions.push_back(new Instruction("INC"));
		
		// wygenerowanie jedynki potrzebnej do shiftów (w komórce memory_pointer)
		// nie jest później potrzebna, więc nie zmieniamy
		// wartości memory_pointer
		instructions.push_back(new Instruction("STORE",memory_pointer));
		
		// w akumulatorze jest 1
		
		for(long long i=1; i<b.size(); i++) {
			instructions.push_back(new Instruction("SHIFT",memory_pointer));
			
			if(b[i] == '1') {
				instructions.push_back(new Instruction("INC"));
			}
		}
		
		instructions.push_back(new Instruction("STORE",cell));
		
	} else {
		number *= -1;
		string b = decToBin(number);
		
		//cout<<b<<endl;
		
		// wygenerowanie jedynki potrzebnej do shiftów (w komórce memory_pointer)
		// nie jest później potrzebna, więc nie zmieniamy
		// wartości memory_pointer
		instructions.push_back(new Instruction("INC"));
		instructions.push_back(new Instruction("STORE",memory_pointer));
		
		instructions.push_back(new Instruction("DEC"));
		instructions.push_back(new Instruction("DEC"));
		
		// w akumulatorze jest -1
		
		for(long long i=1; i<b.size(); i++) {
			instructions.push_back(new Instruction("SHIFT",memory_pointer));
			
			if(b[i] == '1') {
				instructions.push_back(new Instruction("DEC"));
			}
		}
		
		instructions.push_back(new Instruction("STORE",cell));
	}
}

struct cell* findValueInMemory(struct value* value) {
	cell* c = new cell;
	
	if(value->isNumber) {
		c->valueIsNumber = true;
		c->containsValue = false;
		c->containsIndex = false;
		return c;
	} else if(value->isVariable) {
		MemoryItem* memory_item = variables[value->name];
		c->containsValue = true;
		c->valueIsNumber = false;
		c->containsIndex = false;
		c->cell = memory_item->index;
		
		return c;
	} else if(value->isArray) {
		if(value->index_long != -1) { // indeks tablicy był podany jako liczba
			MemoryItem* memory_item = variables[value->name];
						
			// numer komórki pamięci, w której jest zapisane value
			long long index = memory_item->getMemoryIndexOf(value->index_long);
			
			c->cell = index;
			c->containsValue=true;
			c->valueIsNumber = false;
			c->containsIndex = false;
			
			return c;
		} else if(value->index != "") { // indeks tablicy był podany jako nazwa zmiennej
			calculateIndexOfArrayElement(value->name, value->index);
						
			// zapisanie tej wartości w wolnej komórce
			instructions.push_back(new Instruction("STORE", memory_pointer));
			// teraz indeks interesującego nas elementu tablicy jest w komórce
			// o numerze memory_pointer
			
			c->cell = memory_pointer;
			c->containsValue = false;
			c->valueIsNumber = false;
			c->containsIndex = true;
			
			return c;
		}
	}
}

void add(struct value* value1, struct value* value2, long long result_cell) {
	if(value1->isNumber && value2->isNumber) { // jeśli obie wartości to znane liczby
		long long result = value1->num + value2->num;
		
		generateNumberAndStore(result, result_cell);
	} else {
		loadValueToAccumulator(value1);
		instructions.push_back(new Instruction("STORE",memory_pointer));
		// teraz w komórce memory_pointer znajduje się value1
		
		memory_pointer++;
		
		loadValueToAccumulator(value2);
		memory_pointer--;
		
		instructions.push_back(new Instruction("ADD",memory_pointer));
		instructions.push_back(new Instruction("STORE",result_cell));
	}
}

void multiply(struct value* value1, struct value* value2, long long result_cell) {
	if(value1->isNumber && value2->isNumber) { // jeśli obie wartości to znane liczby
		long long result = value1->num * value2->num;
		
		generateNumberAndStore(result, result_cell);
	} else {
		loadValueToAccumulator(value1);
		instructions.push_back(new Instruction("STORE",memory_pointer));
		long long a = memory_pointer;
		// teraz w komórce o numerze a znajduje się value1
		
		memory_pointer++;
		
		loadValueToAccumulator(value2);
		instructions.push_back(new Instruction("STORE",memory_pointer));
		long long b = memory_pointer;
		// teraz w komórce o numerze b znajduje się value2
		
		memory_pointer++;
		
		// generowanie stałych
		instructions.push_back(new Instruction("SUB",0));
		long long zero = memory_pointer; // komórka, w której trzymamy zero
		instructions.push_back(new Instruction("STORE",zero));
		memory_pointer++;
		
		instructions.push_back(new Instruction("INC"));
		long long one = memory_pointer; // komórka, w której trzymamy jedynkę
		instructions.push_back(new Instruction("STORE",one));
		memory_pointer++;
		
		instructions.push_back(new Instruction("DEC"));
		instructions.push_back(new Instruction("DEC"));
		long long minus_one = memory_pointer; // komórka, w której trzymamy minus jedynkę
		instructions.push_back(new Instruction("STORE",minus_one));
		memory_pointer++;
		
		// 
		
		// dodatkowe komórki
		long long c = memory_pointer;
		memory_pointer++;
		long long d = memory_pointer;
		memory_pointer++;
		
		instructions.push_back(new Instruction("LOAD",b));
		instructions.push_back(new Instruction("INC"));
		instructions.push_back(new Instruction("JPOS", instructions.size() + 22));
		
		instructions.push_back(new Instruction("LOAD",a));
		instructions.push_back(new Instruction("INC"));
		instructions.push_back(new Instruction("JPOS", instructions.size() + 13));
		
		instructions.push_back(new Instruction("LOAD",a));
		instructions.push_back(new Instruction("SHIFT",one));
		instructions.push_back(new Instruction("STORE", c));
		instructions.push_back(new Instruction("LOAD",a));
		instructions.push_back(new Instruction("SUB",c));
		instructions.push_back(new Instruction("STORE",a));
		instructions.push_back(new Instruction("LOAD",b));
		instructions.push_back(new Instruction("SHIFT", one));
		instructions.push_back(new Instruction("STORE",c));
		instructions.push_back(new Instruction("LOAD",b));
		instructions.push_back(new Instruction("SUB",c));
		instructions.push_back(new Instruction("STORE",b));
		
		instructions.push_back(new Instruction("LOAD",a));
		instructions.push_back(new Instruction("STORE",c));
		instructions.push_back(new Instruction("LOAD",b));
		instructions.push_back(new Instruction("STORE",a));
		instructions.push_back(new Instruction("LOAD",c));
		instructions.push_back(new Instruction("STORE",b));
		
		instructions.push_back(new Instruction("LOAD",b));
		instructions.push_back(new Instruction("JZERO",instructions.size() + 14));
		instructions.push_back(new Instruction("STORE",d));
		instructions.push_back(new Instruction("SHIFT",minus_one));
		instructions.push_back(new Instruction("STORE",b));
		instructions.push_back(new Instruction("SHIFT",one));
		instructions.push_back(new Instruction("SUB",d));
		instructions.push_back(new Instruction("JZERO",instructions.size() + 4));
		instructions.push_back(new Instruction("LOAD",a));
		instructions.push_back(new Instruction("ADD",zero));
		instructions.push_back(new Instruction("STORE",zero));
		instructions.push_back(new Instruction("LOAD",a));
		instructions.push_back(new Instruction("SHIFT",one));
		instructions.push_back(new Instruction("STORE",a));
		instructions.push_back(new Instruction("JUMP", instructions.size() - 14));
		instructions.push_back(new Instruction("LOAD",zero));
		
		// umieszczenie wyniku we właściwej komórce
		instructions.push_back(new Instruction("STORE",result_cell));
		
		// na końcu odpowiednio zmniejszyć wartość memory_pointer
		memory_pointer = memory_pointer - 7;
	}
}

void divide(struct value* value1, struct value* value2, long long result_cell, bool mod) {
	long long a = memory_pointer;
	loadValueToAccumulator(value1);
	instructions.push_back(new Instruction("STORE",a));
	memory_pointer++;
	
	long long b = memory_pointer;
	loadValueToAccumulator(value2);
	instructions.push_back(new Instruction("STORE",b));
	memory_pointer++;
	
	// przydzielenie numerów komórek do odpowiednich wartości
	
	long long result = memory_pointer;
	memory_pointer++;
	long long one = memory_pointer;
	memory_pointer++;
	long long minus_one = memory_pointer;
	memory_pointer++;
	long long temp = memory_pointer;
	memory_pointer++;
	long long old_b = memory_pointer;
	memory_pointer++;
	long long a_sign = memory_pointer;
	memory_pointer++;
	long long b_sign = memory_pointer;
	memory_pointer++;
	long long pom = memory_pointer;
	memory_pointer++;
	
	// dzielenie z pliku dzielenie2.mr
	
	// wygenerowanie stałych
	instructions.push_back(new Instruction("SUB",0));
	instructions.push_back(new Instruction("STORE",result));
	instructions.push_back(new Instruction("INC"));
	instructions.push_back(new Instruction("STORE",one));
	instructions.push_back(new Instruction("STORE",temp));
	instructions.push_back(new Instruction("STORE",b_sign));
	instructions.push_back(new Instruction("STORE",a_sign));
	instructions.push_back(new Instruction("DEC"));
	instructions.push_back(new Instruction("DEC"));
	instructions.push_back(new Instruction("STORE",minus_one));
	
	// wczytanie wartości, którą trzeba podzielić.
	// w pliku dzielenie2.mr w tym miejscu jest GET
	//loadValueToAccumulator(value1);
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("STORE",a));
	
	// tu zajmujemy się przypadkiem ujemnego a
	instructions.push_back(new Instruction("INC"));
	instructions.push_back(new Instruction("JPOS",instructions.size() + 10));
	instructions.push_back(new Instruction("DEC"));
	instructions.push_back(new Instruction("STORE",a));
	instructions.push_back(new Instruction("SHIFT",one));
	instructions.push_back(new Instruction("STORE",pom));
	instructions.push_back(new Instruction("LOAD",minus_one));
	instructions.push_back(new Instruction("STORE",a_sign));
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("SUB",pom));
	instructions.push_back(new Instruction("STORE",a));
	
	
	// wczytanie wartości dzielnika.
	// w pliku dzielenie2.mr w tym miejscu jest GET
	//loadValueToAccumulator(value2);
	instructions.push_back(new Instruction("LOAD",b));
	instructions.push_back(new Instruction("STORE",b));
	
	instructions.push_back(new Instruction("JZERO",instructions.size() + 45));
	instructions.push_back(new Instruction("STORE",old_b));
	
	// przypadek ujemnego b
	instructions.push_back(new Instruction("INC"));
	instructions.push_back(new Instruction("JPOS",instructions.size() + 11));
	instructions.push_back(new Instruction("DEC"));
	instructions.push_back(new Instruction("STORE",b));
	instructions.push_back(new Instruction("SHIFT",one));
	instructions.push_back(new Instruction("STORE",pom));
	instructions.push_back(new Instruction("LOAD",minus_one));
	instructions.push_back(new Instruction("STORE",b_sign));
	instructions.push_back(new Instruction("LOAD",b));
	instructions.push_back(new Instruction("SUB",pom));
	instructions.push_back(new Instruction("STORE",b));
	instructions.push_back(new Instruction("STORE",old_b));
	
	//pętla 1
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("SUB",b));
	instructions.push_back(new Instruction("JNEG",instructions.size() + 8));
	
	instructions.push_back(new Instruction("LOAD",b));
	instructions.push_back(new Instruction("SHIFT",one));
	instructions.push_back(new Instruction("STORE",b));
	instructions.push_back(new Instruction("LOAD",temp));
	instructions.push_back(new Instruction("SHIFT",one));
	instructions.push_back(new Instruction("STORE",temp));
	instructions.push_back(new Instruction("JUMP",instructions.size() - 9));
	
	//pętla 2
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("SUB",old_b));
	instructions.push_back(new Instruction("JNEG",instructions.size() + 22));
	
	//pętla w pętli 2
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("SUB",b));
	instructions.push_back(new Instruction("INC"));
	instructions.push_back(new Instruction("JPOS",instructions.size() + 8));
	
	instructions.push_back(new Instruction("LOAD",b));
	instructions.push_back(new Instruction("SHIFT",minus_one));
	instructions.push_back(new Instruction("STORE",b));
	instructions.push_back(new Instruction("LOAD",temp));
	instructions.push_back(new Instruction("SHIFT",minus_one));
	instructions.push_back(new Instruction("STORE",temp));
	instructions.push_back(new Instruction("JUMP",instructions.size() - 10));
	
	//dodanie wyniku
	instructions.push_back(new Instruction("LOAD",result));
	instructions.push_back(new Instruction("ADD",temp));
	instructions.push_back(new Instruction("STORE",result));
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("SUB",b));
	instructions.push_back(new Instruction("STORE",a));
	instructions.push_back(new Instruction("JUMP",instructions.size() - 20));
	
	//dzielenie przez zero
	instructions.push_back(new Instruction("SUB",0));
	instructions.push_back(new Instruction("STORE",a));
	instructions.push_back(new Instruction("JUMP",instructions.size() + 42 + 1));
	
	//ustalenie znaku wyniku i reszty
	instructions.push_back(new Instruction("LOAD",a_sign));
	instructions.push_back(new Instruction("JPOS",instructions.size() + 24 + 1));
	instructions.push_back(new Instruction("LOAD",b_sign));
	instructions.push_back(new Instruction("JPOS",instructions.size() + 7 + 1));
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("SHIFT",one));
	instructions.push_back(new Instruction("STORE",pom));
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("SUB",pom));
	instructions.push_back(new Instruction("STORE",a));
	instructions.push_back(new Instruction("JUMP",instructions.size() + 32));
	
	//mały else
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("JZERO",instructions.size() + 7));
	instructions.push_back(new Instruction("LOAD",result));
	instructions.push_back(new Instruction("INC"));
	instructions.push_back(new Instruction("STORE",result));
	instructions.push_back(new Instruction("LOAD",old_b));
	instructions.push_back(new Instruction("SUB",a));
	instructions.push_back(new Instruction("STORE",a));
	
	// po ifie w małym elsie
	instructions.push_back(new Instruction("LOAD",result));
	instructions.push_back(new Instruction("SHIFT",one));
	instructions.push_back(new Instruction("STORE",pom));
	instructions.push_back(new Instruction("LOAD",result));
	instructions.push_back(new Instruction("SUB",pom));
	instructions.push_back(new Instruction("STORE",result));
	instructions.push_back(new Instruction("JUMP",instructions.size() + 17));
	
	//duży else
	instructions.push_back(new Instruction("LOAD",b_sign));
	instructions.push_back(new Instruction("JPOS",instructions.size() + 15));
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("JZERO",instructions.size() + 7));
	instructions.push_back(new Instruction("LOAD",result));
	instructions.push_back(new Instruction("INC"));
	instructions.push_back(new Instruction("STORE",result));
	instructions.push_back(new Instruction("LOAD",a));
	instructions.push_back(new Instruction("SUB",old_b));
	instructions.push_back(new Instruction("STORE",a));
	
	//po drugim ifie w elsie
	instructions.push_back(new Instruction("LOAD",result));
	instructions.push_back(new Instruction("SHIFT",one));
	instructions.push_back(new Instruction("STORE",pom));
	instructions.push_back(new Instruction("LOAD",result));
	instructions.push_back(new Instruction("SUB",pom));
	instructions.push_back(new Instruction("STORE",result));
	
	//wyświetlenie wyniku (tu zamiast wyświetlenia umieszczenie wyniku w odpowiedniej komórce)
	if(!mod) {
		instructions.push_back(new Instruction("LOAD",result));
	} else {
		instructions.push_back(new Instruction("LOAD",a));
	}
	instructions.push_back(new Instruction("STORE",result_cell));
	
	
	// na końcu odpowiednio zmniejszyć wartość memory_pointer
	memory_pointer = memory_pointer - 10;
}

void subtract(struct value* value1, struct value* value2, long long result_cell) {
	if(value1->isNumber && value2->isNumber) { // jeśli obie wartości to znane liczby
		long long result = value1->num - value2->num;
		
		generateNumberAndStore(result, result_cell);
	} else {
		loadValueToAccumulator(value2);
		instructions.push_back(new Instruction("STORE",memory_pointer));
		// teraz w komórce memory_pointer znajduje się value1
		
		memory_pointer++;
		
		loadValueToAccumulator(value1);
		memory_pointer--;
		
		instructions.push_back(new Instruction("SUB",memory_pointer));
		instructions.push_back(new Instruction("STORE",result_cell));
	}
}

void checkConditionNegation(struct cond* c, long long k) {
	struct value* value1 = c->value1;
	struct value* value2 = c->value2;
	string op = c->op;
	
	subtract(value1,value2,0);
	
	if(op == "GE") {
		instructions.push_back(new Instruction("DEC"));
		instructions.push_back(new Instruction("JNEG",0));
	} else if(op == "EQ") {
		instructions.push_back(new Instruction("JPOS",instructions.size() + 4));
		instructions.push_back(new Instruction("STORE",memory_pointer));
		instructions.push_back(new Instruction("SUB",0));
		instructions.push_back(new Instruction("SUB",memory_pointer));
		instructions.push_back(new Instruction("JPOS",0));
	} else if(op == "NEQ") {
		instructions.push_back(new Instruction("JZERO",0));
	} else if(op == "LE") {
		instructions.push_back(new Instruction("INC"));
		instructions.push_back(new Instruction("JPOS",0));
	} else if(op == "LEQ") {
		instructions.push_back(new Instruction("JPOS",0));
	} else if(op == "GEQ") {
		instructions.push_back(new Instruction("JNEG",0));
	}
}

void checkCondition(struct cond* c, long long k) {
	struct value* value1 = c->value1;
	struct value* value2 = c->value2;
	string op = c->op;
	
	subtract(value1,value2,0);
	
	if(op == "GE") {
		instructions.push_back(new Instruction("JPOS",0));
	} else if(op == "EQ") {
		instructions.push_back(new Instruction("JZERO",0));
	} else if(op == "NEQ") {
		instructions.push_back(new Instruction("JPOS",instructions.size() + 4));
		instructions.push_back(new Instruction("STORE",memory_pointer));
		instructions.push_back(new Instruction("SUB",0));
		instructions.push_back(new Instruction("SUB",memory_pointer));
		instructions.push_back(new Instruction("JPOS",0));
	} else if(op == "LE") {
		instructions.push_back(new Instruction("JNEG",0));
	} else if(op == "LEQ") {
		instructions.push_back(new Instruction("DEC"));
		instructions.push_back(new Instruction("JNEG",0));
	} else if(op == "GEQ") {
		instructions.push_back(new Instruction("INC"));
		instructions.push_back(new Instruction("JPOS",0));
	}
}

void loadValueToAccumulator(struct value* value) {

	//test
	//instructions.push_back(new Instruction("loadValueToAccumulator: " + value->name));

	if(value->isVariable) {
		MemoryItem* item = variables[value->name];
		instructions.push_back(new Instruction("LOAD", item->index));
	} else if(value->isArray) {
		// jeśli odwołanie do elementu tablicy następuje przez podanie liczby
		// jako numeru indeksu
		if(value->index_long != -1) {
			
			MemoryItem* memory_item = variables[value->name];
			long long index = memory_item->getMemoryIndexOf(value->index_long);
			instructions.push_back(new Instruction("LOAD", index));
						
		} else { // jeśli odwołanie następuje przez podanie nazwy zmiennej
				// jako numeru indeksu 
						
			calculateIndexOfArrayElement(value->name, value->index);
			// teraz w akumulatorze znajduje się numer komórki,
			// w której przechowywana jest wartość interesuącego nas elementu tablicy
				
			// ładujemy do akumulatora wartość z komórki o numerze równym
			// wartości przechowywanej w akumulatorze
			instructions.push_back(new Instruction("LOADI",0));
		}
	} else if(value->isNumber) {
		// wygenerowanie liczby value->num i umieszczenie w akumulatorze
		generateNumberAndStore(value->num, 0);
	}
}



